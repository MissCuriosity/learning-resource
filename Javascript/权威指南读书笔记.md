### 2017-8-22[P190-200,8.4-8.6]
#### 作为值的函数
  1、将函数赋给变量
  2、将函数赋给对象，即为对象的方法
#### 闭包
  词法作用域[对了解闭包很有帮助]
    1、函数的执行依赖于变量作用域，这个变量作用域在函数定义时决定，而不是调用时决定
    2、基本规则
      函数定义时创建作用域链
      函数执行用到作用域链
 闭包的特性
    函数对象可以通过作用域链相互串联起来，函数体内部的变量都可以保存在函数作用域内
 闭包与垃圾回收
    调用JS函数时，都会创建一个新的对象保存局部变量，并将这个对象添加到作用域中
    函数返回时，就从作用域中将这个绑定变量的对象删除。
    若不存在嵌套的函数，也没有其他引用指向这个绑定对象，就会被当成垃圾回收掉
    若存在嵌套函数，并将他作为返回值返回或存储在某处的属性里，这是就会有一个外部引用指向这个嵌套函数，它就不会被当成垃圾回收，所指向的变量对象也不会被垃圾回收
```
function counter() {
  var n = 0;
  return {
    count: function() {
        return n++;
    },
    reset: function() {
        n = 0;
    }
  }
}

var c = counter();var d = counter();
c.count();
d.count();
//创建两个计数器互不干扰
```
  tips：
    1、嵌套的函数不会将作用域内私有成员复制一份[这就是为什么循环时需要使用闭包的原因]
    2、闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量
    3、闭包具有自己所绑定的arguments，因此闭包内无法直接访问外部函数的arguments，除非外部函数将arguments保存到另外一个变量里
    
### 2017-8-23[P200-205,8.7-8.7.6]
#### length
  arguments.length//函数实参的个数
  arguments.callee.length//函数形参个数
  function.length//函数形参个数
  ```
  function foo(x, y, z) {
	    console.log(arguments.length, arguments.callee.length);
  }
  foo.length;//3
  foo();//0, 3
  ```
#### prototype
   此属性指向一个对象[原型对象]的引用
#### call()、apply()
   共同：第一个参数都是调用函数的母对象
   区别：apply()传入的参数都放在数组中[数组、类数组均可]
   ```
   f.call(o),f.apply)(o);//以对象o的方法调用函数f,o是this
   ==>
   o.m = f;
   o.m();
   delete o.m;
   ```
#### bind()
   将函数绑定至某个对象.返回一个新的闭包函数
   做构造函数调用时会忽略this
```
function foo(x, y, z) {
console.log(this.value + x + y + z);
}
var test = foo.bind({value: 8}, x, y);
test(z);
```
#### toString()
```
   function foo() {
     //do sth
   }
   foo.toString();//"function foo(x, y, z) {//do sth}"
   foo.toString;//function toString() { [native code] }
```
#### Function() 构造函数
   使用Function() 构造函数注意点：P205
     **构造函数所创建的函数并不是使用词法作用域，函数体代码的编译总是会在顶层函数执行
     ```
	     var scope = 'global';
	     function consFunction() {
	       var scope = 'local';
	       return new Function('return scope');//无法捕捉到局部作用域
	     }
	     consFunction()();//'global'
     ```
### 2017-8-27[P213-222， 9.1-9.3]u9开始
#### 构造函数
    首字母大写
    new Function()创造实体
    ```
	    function Range(from, to) {//构造函数；类
		this.from = from;
		this.to = to;
	    }
	    Range.prototype = {//原型对象
		includes: function(x) {
		    return this.from <= x && x < this.to;
		}
	    };
	    var r = new Range(1, 3);//创建一个范围对象
    ```    
#### 构造函数和类的标识
    原型对象是类的唯一标识   
#### constructor属性
    构造函数和原型对象之间的关系：P218
        **实例的原型是构造函数	
#### JS中Java式的类继承
    构造函数对象
    原型对象
        原型对象的属性被类的所有实例继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例方法来调用
    实例对象
    
